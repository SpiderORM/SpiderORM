from spider.fields import Field, PasswordField
from spider.sql_utils import TableSQL
from spider.sqlite.sqlite_connection import SQLIteConnection


class ModelMeta(type):
    """
    Metaclass for defining model fields and metadata.

    This metaclass processes the fields and metadata defined in the model class.
    """

    def __new__(cls, name, bases, attrs):
        # Extract field definitions from the class attributes
        fields = {key: value for key, value in attrs.items() if isinstance(value, Field)}
        new_class = super().__new__(cls, name, bases, attrs)
        new_class._fields = fields
        
        # Process metadata from the MetaData inner class
        meta = attrs.get('MetaData', None)
        if meta:
            new_class._meta = {}
            for attr_name in dir(meta):
                if not attr_name.startswith('_'):
                    new_class._meta[attr_name] = getattr(meta, attr_name)
        
        return new_class


class Model(metaclass=ModelMeta):
    """
    Base model class for interacting with the database.

    Provides methods for CRUD operations and managing metadata.
    """

    class MetaData:
        """
        Metadata configuration for the model.

        Attributes:
        - rdbms (SQLIteConnection): The database connection to be used.
        """
        rdbms = SQLIteConnection()

    def get_meta_attr(self, attr, default=None):
        """
        Retrieves metadata attributes.

        Args:
        - attr (str): The attribute name to retrieve.
        - default: Default value to return if attribute is not found.

        Returns:
        - The value of the metadata attribute or the default value if not found.
        """
        return self._meta.get(attr, default)

    def _rdbms(self):
        """
        Retrieves the database connection.

        Returns:
        - SQLIteConnection: The database connection instance.
        """
        return self._meta.get('rdbms')

    def __init__(self, **kwargs) -> None:
        """
        Initializes a model instance with field values.

        Args:
        - kwargs (dict): Field names and their values to initialize.
        
        Raises:
        - AttributeError: If a provided field name is not valid.
        """
        for key, value in kwargs.items():
            if key in self._fields:
                setattr(self, key, self._fields[key].validate(value))
            else:
                raise AttributeError(f"{key} is not a valid field for {self.__class__.__name__}")

    def create_table(self):
        """
        Creates the table for the model in the database.

        Uses the SQL statements generated by TableSQL.
        """
        sql, sql_safely_password_store = TableSQL.create_table_sql(self)
        with self._rdbms() as conn:
            conn.execute(sql)
            if sql_safely_password_store:
                conn.execute(sql_safely_password_store)
            print('Table created successfully.')

    def filter(self, **kwargs):
        """
        Retrieves data from the table based on filter criteria.

        Args:
        - kwargs (dict): Field names and their values to filter by.

        Returns:
        - list: A list of dictionaries representing the filtered rows.
        """
        query, values = TableSQL.filter_data_sql(self, kwargs)
        with self._rdbms() as conn:
            conn.execute(query, values)
            data = [dict(zip([column[0] for column in conn.description], row)) for row in conn.fetchall()]
            return data

    def get(self, **kwargs):
        """
        Retrieves a specific record from the table based on search criteria.

        Args:
        - kwargs (dict): Field names and their values to search by.

        Returns:
        - dict: The record matching the criteria.

        Raises:
        - ValueError: If no matching record or multiple matching records are found.
        """
        query, values = TableSQL.filter_data_sql(self, kwargs)
        with self._rdbms() as conn:
            conn.execute(query, values)
            data = [dict(zip([column[0] for column in conn.description], row)) for row in conn.fetchall()]
        
        if len(data) == 1:
            return data[0]
        elif len(data) == 0:
            raise ValueError("No matching record found.")
        else:
            raise ValueError("Multiple matching records found.")

    def all(self):
        """
        Retrieves all records from the table.

        Returns:
        - list: A list of tuples representing all rows in the table.
        """
        query = TableSQL.select_all_sql(self)
        with self._rdbms() as conn:
            conn.execute(query)
            data = conn.fetchall()
        return data

    def save(self):
        """
        Saves the current instance to the database.

        Inserts the record into the table and handles password hashing if applicable.
        """
        normal_insert, has_password = TableSQL.insert_data_sql(self)
        query, values = normal_insert
        pk = None
        with self._rdbms() as conn:
            conn.execute(query, values)
            conn.execute(f'SELECT * FROM {self.__class__.__name__.lower()};')
            pk = conn.fetchall()[-1][0]
            if has_password:
                password = None
                conn.execute(f'UPDATE {self.__class__.__name__.lower()} SET passwordID = {pk} WHERE id = {pk};')
                for field_name, field_class in self._fields.items():
                    if isinstance(field_class, PasswordField):
                        password = getattr(self, field_name)
                        salt = field_class.salt
                        hash_name = field_class.hash
                        _iter = field_class.iterations

                from hashlib import pbkdf2_hmac

                salt = salt[0]
                _hash = pbkdf2_hmac(
                    hash_name=hash_name,
                    password=password.encode(),
                    salt=salt.to_bytes(),
                    iterations=_iter
                ).hex()
                query = f"INSERT INTO passwords (id, hash, salt) VALUES ({pk}, '{_hash}', '{salt}');"
                conn.execute(query)
            print("Data recorded successfully.")

    def delete(self, id):
        """
        Deletes a record from the table based on the primary key.

        Args:
        - id (int): The primary key of the record to delete.
        """
        query, param = TableSQL.delete_data_sql(self, id)
        with self._rdbms() as conn:
            conn.execute(query, param)
            print('Data deleted successfully')

    def update(self, **kwargs):
        """
        Updates records in the table based on provided field values.

        Args:
        - kwargs (dict): Field names and their new values.
        """
        query, values = TableSQL().update_data_sql(self, kwargs)
        with self._rdbms() as conn:
            conn.execute(query, values)
            print('Data altered successfully.')
